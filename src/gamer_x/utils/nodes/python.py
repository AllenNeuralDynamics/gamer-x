import json

from langchain_core.messages import ToolMessage,  AIMessage

from gamer_x.utils.models import(
    code_generator_agent,
    python_execute_agent,
    script_reformat_agent
)
from gamer_x.utils.models import(
    SONNET_4_LLM
)
from gamer_x.utils.prompts.python_executor import (
    get_python_excecute_prompt
    )
from gamer_x.utils.prompts.reformat_python import (
    get_reformat_python_prompt
    )
from gamer_x.utils.prompts.python_formatter import (
    get_python_format_prompt
    )
from gamer_x.utils.prompts.python_summarizer import(
    get_python_summary_prompt
)
from gamer_x.utils.tools import python_execute_tools

async def python_formatter(state:dict):
    query = state['query']
    schema_context = state.get('schema_context', [])
    python_code = state.get("python_code", "No code has been generated yet")
    python_code_response = state.get("python_code_response", " ")

    prompt = get_python_format_prompt(
        python_code_response=python_code_response,
        python_code=python_code,
        schema_context=schema_context,
        query=query
    )
    
    try:
        answer = await code_generator_agent.ainvoke(prompt)
        
        # Safe extraction of python_code
        if hasattr(answer, 'tool_calls') and answer.tool_calls:
            python_code = answer.tool_calls[0]['args'].get('python_code', 'No code generated')
        else:
            # Fallback: try to extract from content
            python_code = getattr(answer, 'content', 'No code generated')
            
        return {
            "messages": [python_code],
            "python_code": python_code, 
            "generation": python_code
        }
    except Exception as e:
        error_msg = f"Python formatter failed: {str(e)}"
        return {
            "messages": [AIMessage(content=error_msg)],
            "python_code": error_msg,
            "generation": error_msg
        }

def should_execute(state: dict):
    route = state["code_or_query"]

    if route == "python_script_execute":
        return "execute" 
    # Otherwise if there is, we continue
    else:
        return "summarize"
    
async def python_summarizer(state:dict):
    python_code = state.get("python_code", "No code has been generated yet")
    query = state.get("query")
    python_summary_prompt = get_python_summary_prompt(
        query=query,
        python_code=python_code
    )

    try:
        response = await SONNET_4_LLM.ainvoke(python_summary_prompt)
        
        # Safe content extraction
        if hasattr(response, 'content'):
            if isinstance(response.content, list) and len(response.content) > 0:
                content = response.content[0].get('text', str(response.content))
            else:
                content = str(response.content)
        else:
            content = str(response)

        return {
            "messages": [response], 
            "generation": content
        }
        
    except Exception as e:
        error_msg = f"Python summarizer failed: {str(e)}"
        return {
            "messages": [AIMessage(content=error_msg)],
            "generation": error_msg
        }


async def python_executor(state: dict):
    python_code = state.get("python_code", "No code has been generated yet")
    python_code_response = state.get("python_code_response", "There was no response generated by the script")
    python_execute_count = state.get("python_execute_count", 0)

    python_execute_prompt = get_python_excecute_prompt(
        python_code=python_code,
        python_code_response=python_code_response,
        python_execute_count=python_execute_count
    )
    
    try:
        response = await python_execute_agent.ainvoke(python_execute_prompt)
        
        # Safe content extraction
        if hasattr(response, 'content'):
            if isinstance(response.content, list) and len(response.content) > 0:
                content = response.content[0].get('text', str(response.content))
            else:
                content = str(response.content)
        else:
            content = str(response)

        return {
            "messages": [response],
            "generation": content
        }
        
    except Exception as e:
        error_msg = f"Python executor failed: {str(e)}"
        return {
            "messages": [AIMessage(content=error_msg)],
            "generation": error_msg
        }



async def run_python_script(state: dict):
    """
    Retrieving information from MongoDB with tools
    """

    tool_call_count = state.get("python_execute_count", 0) + 1
    tools_by_name = {tool.name: tool for tool in python_execute_tools}

    outputs = []



    for i, tool_call in enumerate(state["messages"][-1].tool_calls):
        try:
            tool_result = await tools_by_name[tool_call["name"]].ainvoke(
                tool_call["args"]
            )

            content = json.dumps(tool_result)
        except Exception as e:
            content = e

        outputs.append(
            ToolMessage(
                content=content,
                name=tool_call["name"],
                tool_call_id=tool_call["id"],
            )
        )
    
    return {
        "messages": outputs,
        "python_code_response": content,
        "python_execute_count": tool_call_count
    }

def should_continue_python_run(state):
    messages = state["messages"]
    last_message = messages[-1]
    python_execute_count = state.get("python_execute_count", 0)

    # Add maximum retry limit to prevent infinite loops
    if python_execute_count >= 3:
        return "end"
    
    if not hasattr(last_message, 'tool_calls') or not last_message.tool_calls:
        return "end"
    else:
        return "continue"


async def should_reformat(state):

    python_code = state["python_code"]
    python_code_response = state.get(
        "python_code_response", 
        "There was no response generated by the script"
        )
    query = state['query']
    python_execute_count = state.get("python_execute_count", 0)

    prompt = get_reformat_python_prompt(
        python_code=python_code,
        python_code_response=python_code_response,
        query = query,
        python_execute_count=python_execute_count
        )
    
    response = await script_reformat_agent.ainvoke(
        prompt
    )

    reformat = response['reformat']
    return reformat
